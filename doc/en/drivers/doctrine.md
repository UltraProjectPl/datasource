# Doctrine Driver #

This driver allows to fetch data from database using Doctrine2 ORM. 

## Setup ##

You can create driver manually

``` php
<?php

use FSi\Component\DataSource\Driver\Doctrine\DoctrineDriver;
use FSi\Component\DataSource\Driver\Doctrine\Extension\Core\CoreExtension;

$driverExtensions = array(new CoreExtension());

$driver = new DoctrineDriver($driverExtensions, $entityManager, $entityName);

```

or through factory

``` php
<?php

use FSi\Component\DataSource\Driver\Doctrine\DoctrineFactory;
use FSi\Component\DataSource\Driver\Doctrine\Extension\Core\CoreExtension;

$extensions = array(
    // (...) Extensions that have to be loaded to every DataSource after creation.
);

$factory = new DataSourceFactory($extensions);

$driverExtensions = array(new CoreExtension());

$driverFactory = new DoctrineFactory($ManagerRegistry, $driverExtensions);
$driver = $driverFactory->createDriver($entityName); // All drivers created this way will have same set of $driverExtensions loaded.

```

## Provided fields ##

Doctrine driver provides some field types through ``FSi\Component\DataSource\Driver\Doctrine\Extension\Core\CoreExtension``
so remember to **always load it** to this driver.

Provided field types:

* ``text`` - allowed comparisons: eq, neq, in, notIn, like, contains, isNull.
* ``number`` - allowed comparisons: eq, neq, lt, lte, gt, gte, in, notIn, between, isNull.
* ``date`` - allowed comparisons: eq, neq, lt, lte, gt, gte, in, notIn, between, isNull.
* ``time`` - allowed comparisons: eq, neq, lt, lte, gt, gte, in, notIn, between, isNull.
* ``datetime`` - allowed comparisons: eq, neq, lt, lte, gt, gte, in, notIn, between, isNull.
* ``entity`` - allowed comparisons: eq, memberof, in, isNull.
* ``boolean`` - allowed comparisons: eq.

Note: When using ``between`` comparison, you must bind parameters as array('from' => $value1, 'to' => $value2), 
if ``entity`` you must give entity to it and if ``in``, or ``notIn`` then as array.

All fields allow by default to set option ``field`` which usage is explained below.

## Basic usage ##

In the simpliest use case you must just create DataSource with proper entity name:

``` php
<?php

$driverFactoryManager = new DriverFactoryManager(array(
    new DoctrineFactory($entityManager, $driverExtensions);
));

$datasourceFactory = new DataSourceFactory($driverFactoryManager, $datasourceExtensions);

/**
 * Available options for driverOptions are:
 * 'entity' - string
 * 'qb' - QueryBuilder
 * 'alias' - string
 * 'em' - string
 */
$driverOptions = array(
    'entity' => 'Name\Of\Entity' // It can be any entity name that is known to Doctrine.
);
$datasource = $datasourceFactory->createDataSource('doctrine', $driverOptions, 'datasource_name');

$datasource->addField('id', 'number', 'eq')
    ->addField('title', 'text', 'like')
    ->addField('author', 'text', 'eq')
    ->addField('create_date', 'datetime', 'between')
    ->addField('content', 'text', 'like')
    ->addField('category', 'entity', 'eq')
    ->addField('group', 'entity', 'memberof');
```

You can use ``field`` option to have different field name, or many DataSource fields referring to one entity field:

``` php
<?php

$datasource->addField('veryweirdname' 'number', 'eq', array(
        'field' => 'id',
    ))
    ->addField('datefrom', 'datetime', 'gte', array(
        'field' => 'create_date',
    ))
    ->addField('dateto', 'datetime', 'lte', array(
        'field' => 'create_date',
    ));
```

If you use ``field`` option and provide field name without an entity alias (i.e. ``create_date``) then the default alias
is added to the field name used in DQL unless you set ``auto_alias`` option to false.

There's another option provided by all fields from `DoctrineDriver`` named ``clause``. Its default value is ``'where'``
and other available value is ``'having'``. This option determines which DQL clause will contain conditions generated by
corresponding DataSource field.

## Using predefined QueryBuilder ##

You can also use predefined QueryBuilder, and if so, you can pass it to driver options insetad of ``entity``.
If you do you can also pass an alias of entity as additional argument.

``` php
<?php

$queryBuilder = $entityManager->createQueryBuilder();
$queryBuilder->select('n')
    ->from('Name\Of\Entity', 'n')
    ->where('n.active = 1') // All results will have additional condition.;

$driverFactoryManager = new DriverFactoryManager(array(
    new DoctrineFactory($entityManager, $driverExtensions);
));

$datasourceFactory = new DataSourceFactory($driverFactoryManager, $datasourceExtensions);

$driverOptions = array(
    'qb' => $queryBuilder
);
$datasource = $datasourceFactory->createDataSource('doctrine', $driverOptions, 'datasource_name');
```

## Advanced use with QueryBuilder ##

If you want to have conditions to fields from joined entities, or you build very sophisticated query,
remember to add field mapping to all of fields, otherwise they will try do refer to root entity alias.

``` php
<?php

$queryBuilder = $entityManager->createQueryBuilder();
$queryBuilder
    ->select('n')
    ->from('Name\Of\Entity', 'n')
    ->join('n.category', 'c') // Joining category.
    ->where('n.active = 1')
;
$driverFactoryManager = new DriverFactoryManager(array(
    new DoctrineFactory($entityManager, $driverExtensions);
));

$datasourceFactory = new DataSourceFactory($driverFactoryManager, $datasourceExtensions);

$driverOptions = array(
    'qb' => $queryBuilder
);
$datasource = $datasourceFactory->createDataSource('doctrine', $driverOptions, 'datasource_name');
$datasource->addField('id', 'number', 'eq', array('field' => 'n.id'))
    ->addField('title', 'text', 'like', array('field' => 'n.title'))
    ->addField('category_name', 'text', 'like', array( // It's not entity field anymore.
        'field' => 'c.name', // It allow us to specify condition for category name, not just category (as entity).
    ));

```
